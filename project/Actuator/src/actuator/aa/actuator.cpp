///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : actuator.cpp
/// SOFTWARE COMPONENT NAME           : Actuator
/// GENERATED DATE                    : 2024-11-14 15:25:13
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "actuator/aa/actuator.h"
#include "ara/log/logger.h"
#include <fstream>
#include <string>

namespace actuator
{
namespace aa
{

Actuator::Actuator()
    : m_logger(ara::log::CreateLogger("ACTR", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(1)
    , m_running(false)
{
}

Actuator::~Actuator()
{
    servoMgr->servoSubscriber(0, 0);
}

bool Actuator::Initialize()
{
    m_logger.LogVerbose() << "Actuator::Initialize";

    bool init{true};

    // ControlData RPort 객체의 생성
    m_ControlData = std::make_shared<actuator::aa::port::ControlData>();

    // Test Code for Servo Calibration Data
    ServoCalibration();
    // Test Code for Motor Calibration Data
    MotorCalibration();

    return init;
}

void Actuator::Start()
{
    m_logger.LogVerbose() << "Actuator::Start";

    m_ControlData->Start();

    // run software component
    Run();
}

void Actuator::Terminate()
{
    m_logger.LogVerbose() << "Actuator::Terminate";

    m_running = false;

    m_ControlData->Terminate();
}

void Actuator::Run()
{
    m_logger.LogVerbose() << "Actuator::Run";

    m_running = true;

    m_workers.Async([this] { TaskReceiveCEventCyclic(); });

    m_workers.Wait();
}

void Actuator::TaskReceiveCEventCyclic()
{
    m_ControlData->SetReceiveEventCEventHandler([this](const auto &sample)
    {
        OnReceiveCEvent(sample);
    });
    m_ControlData->ReceiveEventCEventCyclic();
}

void Actuator::OnReceiveCEvent(const deepracer::service::controldata::proxy::events::CEvent::SampleType &sample)
{
    m_logger.LogInfo() << "Actuator::OnReceiveCEvent - data = {" << sample[0] << ", " << sample[1] << "}";

    float cur_servo = sample[0];
    float cur_motor = sample[1];

    // 로그를 통해 동작 상태를 확인합니다.
    m_logger.LogInfo() << "Actuator set - Steering: " << cur_servo << ", Throttle: " << cur_motor;

    servoMgr->servoSubscriber(cur_servo, cur_motor);
}

void Actuator::ServoCalibration()
{
    int cal_type=0;
    int servo_min, servo_mid, servo_max, servo_polarity;

    // Print current calibration value
    servoMgr->getCalibrationValue(cal_type, &servo_min, &servo_mid, &servo_max, &servo_polarity);
    m_logger.LogInfo() << "Current Servo calibration value: min: " << servo_min << "mid:" << servo_mid << "max:" << servo_max << "polarity:" << servo_polarity;

}

void Actuator::MotorCalibration()
{
    int cal_type = 1;
    int motor_min, motor_mid, motor_max, motor_polarity;

    // Print current calibration value
    servoMgr->getCalibrationValue(cal_type, &motor_min, &motor_mid, &motor_max, &motor_polarity);
    m_logger.LogInfo() << "Current Servo calibration value: min: " << motor_min << "mid:" << motor_mid << "max:" << motor_max << "polarity:" << motor_polarity;

}

} /// namespace aa
} /// namespace actuator
