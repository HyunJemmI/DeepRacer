///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : actuator.cpp
/// SOFTWARE COMPONENT NAME           : Actuator
/// GENERATED DATE                    : 2024-08-14 09:44:02
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "actuator/aa/actuator.h"
#include "ara/log/logger.h"
#include <fstream>
#include <string>

namespace actuator
{
    namespace aa
    {
        Actuator::Actuator()
            : m_logger(ara::log::CreateLogger("ACTR", "SWC", ara::log::LogLevel::kVerbose)),
              m_workers(1), // m_workers.Async에 등록가능한 함수 갯수
              servoMgr(std::make_unique<PWM::ServoMgr>()),
              ledMgr(std::make_unique<PWM::LedMrg>()),
              m_running(false)
        {
        }

        Actuator::~Actuator()
        {
        }

        // Actuator Software Component의 초기화 함수.
        // 설계하였던 Port 객체들을 생성한다.
        bool Actuator::Initialize()
        {
            m_logger.LogInfo() << "Actuator::Initialize";

            bool init{true};

            // ControlData RPort 객체의 생성
            m_ControlData = std::make_shared<actuator::aa::port::ControlData>();

            // Test Code for Servo Calibration Data
            testServoCalibration();
            // Test Code for Motor Calibration Data
            testMotorCalibration();

            return init;
        }

        // Actuator Software Component의 시작 함수
        void Actuator::Start()
        {
            m_logger.LogInfo() << "Actuator::Start";

            // ControlData RPort 의 Start() 함수를 호출한다.
            m_ControlData->Start();

            // run software component
            Run();
        }

        // Actuator가 종료되어야 할때 호출되는 함수.
        void Actuator::Terminate()
        {
            m_logger.LogInfo() << "Actuator::Terminate";

            m_running = false;

            // ControlData RPort 에 대한 Terminate() 함수를 호출한다.
            m_ControlData->Terminate();

            servoMgr->servoSubscriber(0, 0);
        }

        // Actuator Software Component의 수행 함수
        void Actuator::Run()
        {
            m_logger.LogInfo() << "Actuator::Run";

            m_running = true;

            testFunction();

            // // 수행해야 할 작업에 대해 m_workers.Async() 호출을 통해 등록한다.
            // m_workers.Async([this] { TaskReceiveCEventCyclic(); });

            // // 위의 Async로 등록된 함수들이 모두 리턴될때까지 기다린다.
            // m_workers.Wait();
        }

        // ControlData CEvent의 Cyclic 수신처리에 대한 수행
        void Actuator::TaskReceiveCEventCyclic()
        {
            m_ControlData->SetReceiveEventCEventHandler([this](const auto &sample)
                                                        { OnReceiveCEvent(sample); });
            m_ControlData->ReceiveEventCEventCyclic();
        }

        // ControlData CEvent를 받았을시의 처리 함수(test)
        void Actuator::testFunction()
        {
            m_logger.LogInfo() << "Actuator::testFunction";

            float cur_motor = 0.5f; // throttle
            float cur_servo = 0.5f; // steering

            // 모터 제어 로직
            while (m_running)
            {
                servoMgr->servoSubscriber(cur_motor, cur_servo);

                // 로그를 통해 동작 상태를 확인합니다.
                m_logger.LogInfo() << "Actuator set - Throttle: " << cur_motor << ", Steering: " << cur_servo;
            }
            servoMgr->servoSubscriber(0, 0);
        }

        // ControlData CEvent를 받았을시의 처리 함수
        void Actuator::OnReceiveCEvent(const deepracer::service::controldata::proxy::events::CEvent::SampleType &sample)
        {
            m_logger.LogInfo() << "Actuator::OnReceiveCEvent:" << sample;

            // sample이 unsigned int 타입이므로, 적절히 변환해야 합니다.
            // 예를 들어, 상위 16비트를 throttle로, 하위 16비트를 steering으로 사용할 수 있습니다.
            float cur_motor = static_cast<float>((sample >> 16) & 0xFFFF) / 65535.0f * 2.0f - 1.0f;
            float cur_servo = static_cast<float>(sample & 0xFFFF) / 65535.0f * 2.0f - 1.0f;

            // 모터 제어 로직
            servoMgr->servoSubscriber(cur_motor, cur_servo);

            // 로그를 통해 동작 상태를 확인합니다.
            m_logger.LogInfo() << "Actuator set - Throttle: " << cur_motor << ", Steering: " << cur_servo;
        }

        void Actuator::testServoCalibration()
        {
            int cal_type = 0;
            int servo_min, servo_mid, servo_max, servo_polarity;

            // Print current calibration value
            servoMgr->getCalibrationValue(cal_type, &servo_min, &servo_mid, &servo_max, &servo_polarity);
            m_logger.LogInfo() << "Current Servo calibration value: min: " << servo_min << ", mid: " << servo_mid << ", max: " << servo_max << ", polarity: " << servo_polarity;

            // Set New calibration value
            servoMgr->setCalibrationValue(cal_type, servo_min - 10, servo_mid - 10, servo_max - 10, servo_polarity == 1 ? -1 : 1);

            // Print updated calibration value
            servoMgr->getCalibrationValue(cal_type, &servo_min, &servo_mid, &servo_max, &servo_polarity);
            m_logger.LogInfo() << "New Servo calibration value(-10): min: " << servo_min << ", mid: " << servo_mid << ", max: " << servo_max << ", polarity: " << servo_polarity;

            // Recover calibration value
            servoMgr->setCalibrationValue(cal_type, servo_min + 10, servo_mid + 10, servo_max + 10, servo_polarity == 1 ? -1 : 1);

            // Print recovered calibration value
            servoMgr->getCalibrationValue(cal_type, &servo_min, &servo_mid, &servo_max, &servo_polarity);
            m_logger.LogInfo() << "Recovered Current Servo calibration value: min: " << servo_min << ", mid: " << servo_mid << ", max: " << servo_max << ", polarity: " << servo_polarity;
        }

        void Actuator::testMotorCalibration()
        {
            int cal_type = 1;
            int motor_min, motor_mid, motor_max, motor_polarity;

            // Print current calibration value
            servoMgr->getCalibrationValue(cal_type, &motor_min, &motor_mid, &motor_max, &motor_polarity);
            m_logger.LogInfo() << "Current Motor calibration value: min: " << motor_min << ", mid: " << motor_mid << ", max: " << motor_max << ", polarity: " << motor_polarity;

            // Set New calibration value
            servoMgr->setCalibrationValue(cal_type, motor_min - 10, motor_mid - 10, motor_max - 10, motor_polarity == 1 ? -1 : 1);

            // Print updated calibration value
            servoMgr->getCalibrationValue(cal_type, &motor_min, &motor_mid, &motor_max, &motor_polarity);
            m_logger.LogInfo() << "New Motor calibration value(-10): min: " << motor_min << ", mid: " << motor_mid << ", max: " << motor_max << ", polarity: " << motor_polarity;

            // Recover calibration value
            servoMgr->setCalibrationValue(cal_type, motor_min + 10, motor_mid + 10, motor_max + 10, motor_polarity == 1 ? -1 : 1);

            // Print recovered calibration value
            servoMgr->getCalibrationValue(cal_type, &motor_min, &motor_mid, &motor_max, &motor_polarity);
            m_logger.LogInfo() << "Recovered Current Motor calibration value: min: " << motor_min << ", mid: " << motor_mid << ", max: " << motor_max << ", polarity: " << motor_polarity;
        }
    } /// namespace aa
} /// namespace actuator
