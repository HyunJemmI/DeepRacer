///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : calc.cpp
/// SOFTWARE COMPONENT NAME           : Calc
/// GENERATED DATE                    : 2024-11-14 15:25:13
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "calc/aa/calc.h"

namespace calc
{
namespace aa
{

// 생성자: 클래스 멤버 초기화
Calc::Calc()
    : m_logger(ara::log::CreateLogger("CALC", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(3)
    , m_running(false)
{
}

Calc::~Calc()
{
}

// Client -> Server 연결
bool Calc::Initialize()
{
    m_logger.LogVerbose() << "Calc::Initialize";

    bool init{true};

    m_ControlData = std::make_shared<calc::aa::port::ControlData>();
    m_RawData = std::make_shared<calc::aa::port::RawData>();

    return init;
}

// 시작 함수: 컴포넌트 실행 시작
void Calc::Start()
{
    m_logger.LogVerbose() << "Calc::Start";

    m_ControlData->Start();
    m_RawData->Start();

    Run();
}

// 종료 함수: 리소스 정리 및 스레드 종료
void Calc::Terminate()
{
    m_logger.LogVerbose() << "Calc::Terminate";

    m_running = false;

    m_ControlData->Terminate();
    m_RawData->Terminate();

    m_workers.Wait();
}

// 메인 실행 함수: 작업 스레드 시작
void Calc::Run()
{
    m_logger.LogVerbose() << "Calc::Run";

    m_running = true;

    m_workers.Async([this]{ TaskReceiveREventCyclic(); });
    m_workers.Async([this]{ m_ControlData->SendEventCEventCyclic(); });
    m_workers.Async([this]{ m_RawData->ReceiveFieldRFieldCyclic(); });

    m_workers.Wait();
}

// RawData 이벤트 수신 작업 함수
void Calc::TaskReceiveREventCyclic()
{
    m_RawData->SetReceiveEventREventHandler([this](const auto &sample)
    { 
        OnReceiveREvent(sample); 
    });
    m_RawData->ReceiveEventREventCyclic();
}

// RawData 이벤트 수신 처리 함수
void Calc::OnReceiveREvent(const deepracer::service::rawdata::proxy::events::REvent::SampleType &sample)
{
    std::vector<uint8_t> bufferCombined = sample;

    m_logger.LogInfo() << "Calc::OnReceiveREvent - buffer size = " << bufferCombined.size();

    std::vector<float> result = dataProcess(bufferCombined);

    m_logger.LogInfo() << "Calc::OnReceiveREvent - Mapping Input = {" << result[0] << " , " << result[1] << "}"

    float steering = mapsteering(result[0]);
    float throttle = mapThrottle(result[1]);

    deepracer::type::FloatArray result = {steering , throttle}
    // ControlData 서비스의 CEvent로 전송해야 할 값을 변경한다. 이 함수는 전송 타겟 값을 변경할 뿐 실제 전송은 다른 부분에서 진행된다.
    m_ControlData->WriteDataCEvent(result);
    m_logger.LogInfo() << "m_ControlData::WriteDataCEvent({ " << steering << " , " << throttle << " })";
}

float Calc::mapsteering(float input_value)
{
    float output = std::max(-1.0f, std::min(1.0f, input_value));
    return output;
}

// mapping
float Calc::mapThrottle(float input_value)
{
    float input = abs(input_value);
    // 이차 함수에 따라 스로틀 값을 매핑 (y = -0.133333x^2 + 0.733333x)
    float output = -0.133333f * input * input + 0.733333f * input;
    
    // 출력 값이 0 ~ 1 범위 내에 있는지 확인하고 제한
    output = std::max(0.0f, std::min(1.0f, output));
    
    return output;
}

std::vector<float> Calc::dataProcess(std::vector<uint8_t> input_vector){
    ov::Core core;

    std::string model_path = "~/carina/project/Calc/src/calc/aa/model.xml";
    auto model = core.read_model(model_path);
    auto compiled_model = core.compile_model(model, "CPU");

    auto input_port = compiled_model.input();
    auto output_port = compiled_model.output();

    // 입력 데이터 형식 생성
    ov::Tensor input_tensor(input_port.get_element_type(), input_port.get_shape(), input_vector.data);

    // 추론 실행
    auto result = compiled_model.infer({{input_port, input_tensor}});

    // 출력 결과 가져오기
    auto output_tensor = result.at(output_port);
    float* output_data = output_tensor.data<float>();

    // 조향각 및 속도 결과 계산
    m_logger.LogInfo() << "Calc::dataProcess - {steering = " << output_data[0] << " , speed = " << output_data[1] << " }";

    // 조향각 및 속도 결과 계산
    std::vector<float> result = {steering, speed}

    return result
}

} /// namespace aa
} /// namespace calc
