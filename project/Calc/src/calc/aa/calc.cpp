///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : calc.cpp
/// SOFTWARE COMPONENT NAME           : Calc
/// GENERATED DATE                    : 2024-11-14 15:25:13
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "calc/aa/calc.h"
#include "calc/aa/inference_engine_wrapper.h"
#include <iostream>
#include <array>

namespace calc
{
namespace aa
{

// 생성자: 클래스 멤버 초기화
Calc::Calc()
    : m_logger(ara::log::CreateLogger("CALC", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(3)
    , m_running(false)
{
}

Calc::~Calc()
{
}

// Client -> Server 연결
bool Calc::Initialize()
{
    m_logger.LogVerbose() << "Calc::Initialize";

    bool init{true};

    m_ControlData = std::make_shared<calc::aa::port::ControlData>();
    m_RawData = std::make_shared<calc::aa::port::RawData>();

    return init;
}

// 시작 함수: 컴포넌트 실행 시작
void Calc::Start()
{
    m_logger.LogVerbose() << "Calc::Start";

    m_ControlData->Start();
    m_RawData->Start();

    Run();
}

// 종료 함수: 리소스 정리 및 스레드 종료
void Calc::Terminate()
{
    m_logger.LogVerbose() << "Calc::Terminate";

    m_running = false;

    m_ControlData->Terminate();
    m_RawData->Terminate();

    m_workers.Wait();
}

// 메인 실행 함수: 작업 스레드 시작
void Calc::Run()
{
    m_logger.LogVerbose() << "Calc::Run";

    m_running = true;

    m_workers.Async([this]{ TaskReceiveREventCyclic(); });
    m_workers.Async([this]{ m_ControlData->SendEventCEventCyclic(); });
    m_workers.Async([this]{ m_RawData->ReceiveFieldRFieldCyclic(); });

    m_workers.Wait();
}

// RawData 이벤트 수신 작업 함수
void Calc::TaskReceiveREventCyclic()
{
    m_RawData->SetReceiveEventREventHandler([this](const auto &sample)
    { 
        OnReceiveREvent(sample); 
    });
    m_RawData->ReceiveEventREventCyclic();
}

// RawData 이벤트 수신 처리 함수
void Calc::OnReceiveREvent(const deepracer::service::rawdata::proxy::events::REvent::SampleType &sample)
{
    std::vector<uint8_t> bufferCombined = sample;

    m_logger.LogInfo() << "Calc::OnReceiveREvent - buffer size = " << bufferCombined.size();

    std::vector<float> result = dataProcess(bufferCombined);

    m_logger.LogInfo() << "Calc::OnReceiveREvent - Mapping Input = {" << result[0] << " , " << result[1] << "}";

    float steering = mapsteering(result[0]);
    float throttle = mapThrottle(result[1]);

    std::array<float,2> mapped = {steering , throttle};
    // ControlData 서비스의 CEvent로 전송해야 할 값을 변경한다. 이 함수는 전송 타겟 값을 변경할 뿐 실제 전송은 다른 부분에서 진행된다.
    m_ControlData->WriteDataCEvent(mapped);
    m_logger.LogInfo() << "m_ControlData::WriteDataCEvent({ " << steering << " , " << throttle << " })";
}

float Calc::mapsteering(float input_value)
{
    float output = std::max(-1.0f, std::min(1.0f, input_value));
    return output;
}

// mapping
float Calc::mapThrottle(float input_value)
{
    float input = abs(input_value);
    // 이차 함수에 따라 스로틀 값을 매핑 (y = -0.133333x^2 + 0.733333x)
    float output = -0.133333f * input * input + 0.733333f * input;
    
    // 출력 값이 0 ~ 1 범위 내에 있는지 확인하고 제한
    output = std::max(0.0f, std::min(1.0f, output));
    
    return output;
}

std::vector<float> Calc::dataProcess(std::vector<uint8_t> input_vector){
    // 모델 경로 및 디바이스 설정
    std::string modelPath = "./model.xml"; // 실제 경로로 변경
    std::string deviceName = "CPU";

    // 추론 엔진 생성
    InferenceEngineWrapper engine(modelPath, deviceName);

    // 입력 데이터 설정 (예: 임의 데이터)
    engine.setInputData(input_vector);

    // 추론 실행
    std::vector<float> results = engine.runInference();

    // 결과 출력
    return {results[0], results[1]};
}

} /// namespace aa
} /// namespace calc
