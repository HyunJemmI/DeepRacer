///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : simactuator.cpp
/// SOFTWARE COMPONENT NAME           : SimActuator
/// GENERATED DATE                    : 2024-11-01 13:31:53
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "simactuator/aa/simactuator.h"

namespace simactuator
{
    namespace aa
    {

        SimActuator::SimActuator()
            : m_logger(ara::log::CreateLogger("SACT", "SWC", ara::log::LogLevel::kVerbose)), m_workers(1), m_running(false)
        {
        }

        SimActuator::~SimActuator()
        {
        }

        bool SimActuator::Initialize()
        {
            m_logger.LogVerbose() << "SimActuator::Initialize";

            bool init{true};

            m_ControlData = std::make_shared<simactuator::aa::port::ControlData>();

            return init;
        }

        void SimActuator::Start()
        {
            m_logger.LogVerbose() << "SimActuator::Start";

            m_ControlData->Start();

            // run software component
            Run();
        }

        void SimActuator::Terminate()
        {
            m_logger.LogVerbose() << "SimActuator::Terminate";

            m_running = false;

            m_ControlData->Terminate();
        }

        void SimActuator::Run()
        {
            m_logger.LogVerbose() << "SimActuator::Run";

            m_running = true;

            m_workers.Async([this]
                            { m_ControlData->ReceiveEventCEventCyclic(); });

            m_workers.Wait();
        }

        void SimActuator::TaskReceiveCEventCyclic()
        {
            m_ControlData->SetReceiveEventCEventHandler([this](const auto &sample)
                                                        { OnReceiveCEvent(sample); });
            m_ControlData->ReceiveEventCEventCyclic();
        }

        void SimActuator::OnReceiveCEvent(const deepracer::service::controldata::proxy::events::CEvent::SampleType &sample)
        {
            m_logger.LogInfo() << "SimActuator::OnReceiveCEvent - data size = " << sample.size();
        }

    } /// namespace aa
} /// namespace simactuator
